
"""
    1.在python中(元组与列表的区别):
        列表是可变（mutable）的,而元组是不可变（immutable）的。
    2. 性能与内存
        因为元组不可变，Python解释器在分配内存时，知道其大小是固定的，因此可以做出大量优化，
        使得元组在创建速度和存储效率上都优于列表。
        -----------------------------------------------------------------------
        对于存储大量数据（例如数百万个元素）的情况，使用元组可以节省可观的内存。
        在遍历操作上，元组的速度也略快于列表。
    3.用途与设计意图
        使用列表的场景：你需要一个可以随时增删改查的集合。例如：
        存储用户动态输入的数据。
        需要排序、反转等操作的集合。
        作为栈（Stack）或队列（Queue）等数据结构的基础（虽然collections.deque更适合队列）。
"""

# 列表 (可变)
my_list = [10, 20, 30]
my_list[0] = 100  # 修改第一个元素，合法
print(my_list)    # 输出: [100, 20, 30]

my_list.append(40) # 添加元素，合法
print(my_list)    # 输出: [100, 20, 30, 40]

del my_list[1]    # 删除第二个元素，合法
print(my_list)    # 输出: [100, 30, 40]

# ---------------------------------------------------------------------------------------------------
# 元组 (不可变)
my_tuple = (10, 20, 30)
# my_tuple[0] = 100  # 尝试修改，会抛出 TypeError 错误
# my_tuple.append(40) # 尝试添加，会抛出 AttributeError 错误

# 但是,如果元组中包含可变元素(如列表),这个可变元素本身是可以被修改的
complex_tuple = (1, 2, [3, 4])
complex_tuple[2][0] = 99  # 这是合法的，因为修改的是元组内部的列表
print(complex_tuple)      # 输出: (1, 2, [99, 4])

"""
使用元组的场景：你需要确保数据不会被意外修改. 例如：
    函数返回多个值：return (width, height)。
    这实际上返回的是一个元组。
    print(valid_dict_key[(1, 2)]) # 输出: This is a value
    
表示常量集: 例如颜色RGB值、数学常数等,你希望这些值在程序中保持不变.
BLACK = (0, 0, 0)
在函数参数中传递不可变数据,可以防止函数内部修改原始数据（虽然对于不可变对象,修改本来就会创建新对象）。
"""

# 列表不能作为键,会报错
#  invalid_dict_key = {[1, 2]: "value"}

# 元组可以作为键
valid_dict_key = {(1, 2): "This is a value"}
print(valid_dict_key[(1, 2)]) # 输出: This is a value

