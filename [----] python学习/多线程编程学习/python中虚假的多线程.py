
# 新凯来, 半导体生产制造, (深圳龙岗, 平湖制造园) (长期项目)
# JIL, python中虚假的多线程

"""
    什么叫做python中虚假的多线程 ?
    Python（特指 CPython，即官方标准实现）中的多线程对于 CPU 密集型任务来说是“虚假”的，
    因为它受到 GIL 的限制，同一时刻只能有一个线程在执行 Python 字节码，
    无法真正利用多核 CPU 进行并行计算，其行为更像是“单线程”。
    但对于 I/O 密集型任务，它仍然是有效的，能够显著提升程序效率。
"""

""" 
1. 什么是 GIL？
    GIL 是一个全局互斥锁,它要求任何线程在执行 Python 字节码之前,都必须先获得这把锁.
    这意味着,即使在多核 CPU 上运行一个多线程的 Python 程序,在任何一个时刻,也只有一个线程处于执行状态.
目的:
    GIL 的存在主要是为了简化 CPython 解释器的实现,特别是内存管理.
    因为 Python 使用引用计数来管理内存,如果没有 GIL,多个线程同时修改一个对象的引用计数时,
    可能会导致内存错误或数据竞争（Race Condition）.
    GIL 用一种简单粗暴的方式解决了这个问题.
代价：
    代价就是牺牲了在多核 CPU 上并行执行 CPU 密集型代码的能力.
----------------------------------------------------------------------------------------------------
2. “虚假”的多线程,“虚假”体现在哪里？
    假设你有一个 4 核 CPU,并创建了 4 个线程来执行一个计算密集型任务（比如计算圆周率、处理图像等）。

理想情况（真正的多线程）:
    4 个线程应该分别跑在 4 个核心上,同时工作,计算时间缩短到原来的 ~1/4.
Python 的情况（虚假的多线程）:
    由于 GIL 的存在,4 个线程会争抢这一把锁.
    抢到锁的线程开始工作,其他线程则处于等待状态.
    线程之间会频繁地进行切换（上下文切换）,但这个切换是由解释器控制的.
    最终结果是，多个线程在一个核心上“来回横跳”,不仅没有减少总时间,反而因为线程切换的开销,有时甚至比单线程更慢.
这个过程可以类比为:
    一个厨房（CPU）有4个灶台（核心）,但只有一把菜刀（GIL）.
    请了4个厨师（线程）来做一道需要大量切菜的菜（CPU密集型任务）.
    厨师们不能同时切菜,他们必须轮流使用那把唯一的菜刀.
    大部分时间,只有一个厨师在切菜,其他三个在旁边看着等待.
    这显然没有提高效率,反而可能因为交接菜刀的过程而降低整体速度.
----------------------------------------------------------------------------------------------------
3. 什么时候多线程仍然有效？
    尽管有 GIL，Python 的多线程在 I/O 密集型任务 中依然非常有用。
    什么是 I/O 密集型任务？这类任务大部分时间在等待输入/输出操作完成，
比如:
    网络请求（爬虫、调用 API）
    读写磁盘文件
    与数据库交互
    为什么有效？当一个线程执行到 I/O 操作（如 requests.get()）时,它会进入等待状态。
    在等待期间,它会主动释放 GIL.
    这时，其他正在等待的线程就可以立即获得 GIL 并开始执行它们的代码。
    这样，多个线程可以高效地重叠各自的等待时间，从而让程序在等待一个响应的同时去处理另一个请求，大大提高了整体吞吐量。

继续用厨房的类比:
    现在厨师们要做的是需要长时间炖煮的菜（I/O操作）.
    一个厨师把肉放进锅里炖上（发起I/O请求）后,他就不需要守着锅了（释放GIL）,
    可以把菜刀交给下一个厨师去切下一道菜的配菜（执行CPU代码）.
    这样,尽管只有一把菜刀,但厨师们都能有效地工作,不会空闲,整个出菜效率大大提高.
----------------------------------------------------------------------------------------------------
如何绕过 GIL？—— 真正的并行计算
如果你确实需要在 Python 中实现真正的、利用多核的并行计算,有以下几种主流方法：

使用 multiprocessing 模块(多进程):
    这是最常用、最直接的方法.
    multiprocessing 通过创建多个 Python 进程 来绕过 GIL.
    每个进程都有自己独立的 Python 解释器和内存空间,因此每个进程都有自己的 GIL,不存在锁争抢.
    可以真正实现多核并行.
    缺点是进程创建和销毁的开销比线程大,进程间通信（IPC）也比线程间通信更复杂.

使用 C 扩展:
    在执行密集型计算时,可以将关键部分用 C/C++ 编写成扩展模块.
    在 C 代码中,可以手动释放 GIL,从而允许其他线程运行.
    计算完成后再重新获取 GIL.
    科学计算库（如 NumPy, Pandas）底层大量使用 C/Fortran 实现,
    所以在执行这些库的函数时,GIL 通常是释放的.
使用其他解释器:
    Jython 和 IronPython 是运行在 JVM 和 .NET 平台上的 Python 实现,它们没有 GIL,可以实现真正的多线程.
    但它们通常滞后于 CPython 的版本更新,且对用 C 编写的扩展库兼容性较差.
    PyPy 也有 GIL，但其本身的 JIT (即时编译)编译器能极大提升代码速度,在某些场景下可以弥补多线程的不足.
使用 concurrent.futures 模块:
    这个模块提供了高层接口，你可以方便地选择使用 
    ThreadPoolExecutor（线程池，受GIL限制）还是 ProcessPoolExecutor (进程池，绕过GIL).
----------------------------------------------------------------------------------------------------
总结对比:
    特性	        多线程 (threading)               多进程 (multiprocessing)
    执行实体	    线程	                            进程
    内存共享	    共享同一进程内存,数据交换简单	    内存独立,需使用队列(Queue)、管道(Pipe)等IPC
    GIL影响	    受严重影响,无法并行执行 CPU 代码    不受影响,每个进程有独立 GIL,可真正并行
    开销	        创建开销小,切换开销小	            创建开销大,切换开销大
    适用场景	    I/O 密集型任务（网络、文件操作）	    CPU 密集型任务（计算、数据处理）

结论:
    “Python 的多线程是假的”这个说法虽然不完全准确,但它生动地指出了 GIL 对 CPU 密集型多线程程序的限制。
    在选择并发方案时,一定要根据任务类型（I/O 密集型 vs. CPU 密集型）来决定使用多线程还是多进程。
"""

