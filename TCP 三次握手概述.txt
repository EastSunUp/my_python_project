

------------------------------------------------------------------------------------------------------------------------
什么时候会使用 TCP 协议?
    TCP 协议的核心特点是面向连接、可靠交付、按序到达、提供流量控制和拥塞控制.
    当你需要确保数据的完整性、正确性和顺序性比传输速度更重要时,就应该使用 TCP.
    以下是一些典型的应用场景:
        Web 浏览 (HTTP/HTTPS):
            当你访问一个网站（如 https://www.example.com）,
            浏览器通过 TCP 连接到服务器的 80 (HTTP) 或 443 (HTTPS) 端口.
            网页的 HTML、CSS、JavaScript、图片等文件必须完整无误地传输,TCP 保证了这一点.
        文件传输 (FTP, SFTP, SCP):
            使用 FileZilla, WinSCP 等工具上传或下载文件时.
            文件内容不能有任何丢失或错乱，TCP 的可靠传输机制确保了文件的完整性.
        电子邮件发送与接收 (SMTP, POP3, IMAP):
            发送邮件 (SMTP) 和接收邮件 (POP3/IMAP)
            都需要保证邮件内容、附件等准确无误地传递,TCP 是这些协议底层的支撑.
        远程登录 (SSH, Telnet):
            使用 PuTTY, OpenSSH 等工具远程登录到服务器进行操作.
            你输入的每一个命令和服务器返回的每一个字符都必须准确无误、按顺序到达,
            TCP 提供了这种可靠的交互通道.
        数据库访问:
            应用程序连接 MySQL, PostgreSQL, SQL Server, Oracle 等数据库时,通常使用 TCP 连接.
            数据库查询和结果集的传输要求极高的准确性.
        安全通信的基础:
            许多安全协议,如 TLS/SSL (用于 HTTPS, SMTPS, IMAPS 等),都是在 TCP 连接之上建立的.
            TCP 提供的可靠字节流是安全协议实现加密、认证等复杂操作的基础.
        需要保证数据顺序和完整性的其他应用：
            企业应用系统间的数据交换、金融交易系统、版本控制系统 (如 Git over SSH/HTTPS) 等,
            只要对数据准确性有严格要求,通常都会选择 TCP.
------------------------------------------------------------------------------------------------------------------------
Seq（全称 Sequence Number,即 序列号）
    在 TCP 中:
        每个字节的数据都有一个唯一序列号（不是按包编号,而是按字节编号！）
        发送方在 TCP 包头中携带 当前数据段的起始序列号 (Seq 值).
SYN (Synchronize - 同步)
    含义:
        表示这是一个请求建立新连接的报文.
        它用于初始化序列号.
ACK (Acknowledge - 确认)
    含义:
        表示该数据包中的确认号字段是有效的,用于确认已成功收到对方发送的数据.
SYN-ACK
    含义:
         SYN-ACK 并不是 TCP 头中的一个独立的标志位 !
         它是一个组合状态,指代在同一个 TCP 包中同时设置了 SYN=1 和 ACK=1.
------------------------------------------------------------------------------------------------------------------------
Client (主动打开)                                    Server (被动打开)
    |                                                     |
    |         SYN (Seq=X)                                 |
    | ---------------------------------------------------> |  [第一次握手] (客户端发送 SYN)
    |                                                     |  (Server State: SYN_RCVD)
    |         SYN-ACK (Seq=Y, Ack=X+1)                    |
    | <--------------------------------------------------- |  [第二次握手] (服务器发送 SYN-ACK)  |                                     |
    |         ACK (Ack=Y+1)                               |   (Client State: ESTABLISHED)
    | ---------------------------------------------------> |  [第三次握手] (客户端发送 ACK)
    |                                                     |   (Server State: ESTABLISHED)
    |                                                     |
    |             [数据传输开始]                            |
------------------------------------------------------------------------------------------------------------------------
    为什么需要三次握手？两次不行吗？
    防止已失效的连接请求报文段造成错误:
        想象一个场景:
            客户端发送了一个 SYN 请求建立连接（第一次握手）,但这个包在网络中被严重延迟了.
            客户端等不到响应,超时后重发了一个新的 SYN 并成功建立了连接传输完数据关闭了连接.
            这时,之前那个延迟的旧 SYN 包终于到达了服务器.
            如果只有两次握手（服务器收到 SYN 就认为连接建立）,
            服务器会误以为这是一个新的连接请求,会为它分配资源并发送 SYN-ACK,
            然后直接进入 ESTABLISHED 状态等待客户端发送数据.
            这会浪费服务器资源,并且客户端收到这个意料之外的 SYN-ACK 会直接丢弃(因为它没有发起这个连接请求).
        三次握手避免了这种情况:
            服务器发送 SYN-ACK 后,必须等待客户端的 ACK 确认才会建立连接.
            在延迟 SYN 的场景中,客户端(你的电脑)收到这个迟到的 SYN-ACK
            不会发送 ACK (因为它没有发起这个连接),服务器最终会超时关闭这个半开的连接.

    可靠地交换初始序列号 (ISN):
            三次握手确保了双方都确认了对方的初始序列号,并且知道对方已经确认了自己的初始序列号.
            这是 TCP 实现可靠传输（按序到达、无丢失、无重复）和流量控制的基础.

    确保双方都具备发送和接收能力:
        第一次握手证明客户端能发送;
        第二次握手证明服务器能接收和发送;
        第三次握手证明客户端能接收.
        三次交互确保了双向通信能力.

------------------------------------------------------------------------------------------------------------------------
用快递类比整个过程
    三次握手:
             你 (客户端) 打电话给快递公司（服务器）说“我要寄快递”（SYN）.
             快递公司确认你的电话能打通,并回复说“好的,我们准备好收件了,请告诉我包裹编号规则”（SYN-ACK）.
             你回复“好的,编号规则按XXX”（ACK）.
             这建立了“寄件”的约定.
    序列号/确认号:
            你寄出的每个包裹（数据包）都有唯一编号（序列号）.
            快递公司每成功收到一个包裹,就给你发个回执 (确认包),
            上面写着“编号为XXXX之前的包裹都已收到,下一个期待编号是YYYY”（确认号）.
            这让你知道哪些包裹对方收到了.
    重传:
            如果你寄出包裹3号后,迟迟没收到回执（超时）,
            你就知道包裹可能丢了,会再寄一个包裹3号（重传）.
    校验和:
            快递公司在收到包裹时会检查包裹是否破损（校验和）.
            如果破损,他们会直接丢弃（不签收）,也不会给你发这个包裹的回执.
            你收不到回执,超时后就会重寄.
    排序:
            包裹可能走不同的路线（3号包裹可能比2号包裹先到快递公司）.
            快递公司会根据包裹编号（序列号）把包裹按顺序整理好（排序）,再交给收件人（上层应用）.
    流量控制:
            快递公司仓库（接收缓冲区）快满了,就通知你“仓库快满了,慢点寄”（调小窗口大小）.
            你就会暂停或放慢寄件速度.
    拥塞控制:
            你发现最近寄包裹经常丢件（网络拥堵信号）,
            你就主动减少每次寄出的包裹数量,降低寄件频率,等路况好了再慢慢增加.

------------------------------------------------------------------------------------------------------------------------